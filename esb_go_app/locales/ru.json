{
    "Go 1C:ESB Fake API is running. Visit /admin to configure.": "Go 1C:ESB Fake API запущен. Посетите /admin для настройки.",
    "Route created successfully!": "Маршрут успешно создан!",
    "Route deleted.": "Маршрут удален.",
    "Route created, but worker start failed. Check logs.": "Маршрут создан, но не удалось запустить обработчик. Проверьте логи.",
    "Route updated successfully!": "Маршрут успешно обновлен!",
    "Route name cannot be empty.": "Имя маршрута не может быть пустым.",
    "Route Management": "Управление маршрутами",
    "Here you can link outbound channels of some applications to inbound channels of others.": "Здесь вы можете связывать исходящие (`outbound`) каналы одних приложений с входящими (`inbound`) каналами других.",
    "Create New Route": "Создать новый маршрут",
    "Route Name:": "Название маршрута:",
    "Integration (optional)": "Интеграция (опционально)",
    "-- None --": "-- Нет --",
    "From Channel (Source)": "Из канала",
    "-- Select source --": "-- Выберите источник --",
    "Route Type": "Тип маршрута",
    "Direct": "Прямой",
    "With Transformation": "С трансформацией",
    "Transformation": "Трансформация",
    "Destination": "Назначение",
    "Destination (Queue)": "Назначение",
    "Application ID": "ID Программы",
    "Client ID (Name)": "ID Программы",
    "Client Secret": "Пароль",
    "-- Select transformation --": "-- Выберите трансформацию --",
    "To Channel (Destination)": "В канал",
    "-- Select inbound channel --": "-- Выберите входящий канал --",
    "Create Route": "Создать маршрут",
    "Existing Routes": "Существующие маршруты",
    "Name": "Название",
    "Source": "Источник",
    "Destination / Transformation": "Назначение / Трансформация",
    "Type": "Тип",
    "Integration": "Интеграция",
    "Created": "Создан",
    "Action": "Действие",
    "Transformation:": "Трансформация:",
    "Are you sure you want to delete this route?": "Вы уверены, что хотите удалить этот маршрут?",
    "Delete": "Удалить",
    "No routes created yet.": "Пока не создано ни одного маршрута.",
    "Source and Destination channels must be selected.": "Необходимо выбрать исходный и целевой каналы.",
    "Transformation must be selected for transform routes.": "Для маршрутов с трансформацией необходимо выбрать трансформацию.",
    "Back to route list": "Назад к списку маршрутов",
    "Route:": "Маршрут:",
    "Route Details": "Детали маршрута",
    "Application:": "Приложение:",
    "Channel:": "Канал:",
    "Name:": "Название:",
    "Update Route": "Обновить маршрут",
    "Route not found.": "Маршрут не найден.",
    "-- No integration --": "-- Без интеграции --",
    "Source Channel:": "Исходный канал:",
    "Destination Channel:": "Канал назначения:",
    "Settings": "Настройки",
    "Language": "Язык",
    "Save Settings": "Сохранить настройки",
    "Settings updated successfully.": "Настройки успешно обновлены.",
    "Application created successfully!": "Приложение успешно создано!",
    "All queues and routes recreated successfully!": "Все очереди и маршруты успешно пересозданы!",
    "Pruned orphan channels: %s": "Удалено 'осиротевших' каналов: %s",
    "Applications": "Приложения",
    "Maintenance": "Обслуживание",
    "Are you sure you want to delete all channels that do not belong to any application?": "Вы уверены, что хотите удалить все каналы, которые не принадлежат ни одному приложению?",
    "Delete 'orphaned' channels": "Удалить 'осиротевшие' каналы",
    "Reconcile RabbitMQ Queues": "Сверить очереди RabbitMQ",
    "Create New Application": "Создать новое приложение",
    "Application Name:": "Название приложения:",
    "Create": "Создать",
    "Existing Applications": "Существующие приложения",
    "Actions": "Действия",
    "Are you sure you want to delete this application?": "Вы уверены, что хотите удалить это приложение?",
    "No applications created.": "Нет созданных приложений.",
    "Service version:": "Версия сервиса:",
    "Author:": "Автор:",
    "Repository on GitHub": "Репозиторий на GitHub",
    "Channel created successfully.": "Канал успешно создан.",
    "Channel deleted.": "Канал удален.",
    "Application name cannot be empty.": "Название приложения не может быть пустым.",
    "Channel updated successfully!": "Канал успешно обновлен!",
    "1 message received and deleted from the persistent queue.": "1 сообщение получено и удалено из постоянной очереди.",
    "The persistent queue store is empty.": "Постоянная очередь-хранилище пуста.",
    "Channel name and destination are required.": "Имя и назначение канала обязательны.",
    "Failed to retrieve channel: %s": "Не удалось получить канал: %s",
    "Channel not found.": "Канал не найден.",
    "Failed to update channel: %s": "Не удалось обновить канал: %s",
    "Failed to retrieve application for test.": "Не удалось получить приложение для теста.",
    "Failed to retrieve channels for test.": "Не удалось получить каналы для теста.",
    "Failed to parse form": "Не удалось разобрать форму",
    "Collector created successfully!": "Сборщик успешно создан!",
    "Collector deleted.": "Сборщик удален.",
    "Collector updated successfully!": "Сборщик успешно обновлен!",
    "All fields except integration are required.": "Все поля, кроме интеграции, обязательны для заполнения.",
    "Failed to retrieve collectors: %s": "Не удалось получить сборщики: %s",
    "Failed to retrieve integrations: %s": "Не удалось получить интеграции: %s",
    "Failed to retrieve collector: %s": "Не удалось получить сборщик: %s",
    "Collector not found.": "Сборщик не найден.",
    "Failed to create collector: %s": "Не удалось создать сборщик: %s",
    "Failed to update collector: %s": "Не удалось обновить сборщик: %s",
    "Failed to delete collector: %s": "Не удалось удалить сборщик: %s",
    "Integration created successfully!": "Интеграция успешно создана!",
    "Integration deleted.": "Интеграция удалена.",
    "Integration name cannot be empty.": "Название интеграции не может быть пустым.",
    "Integration not found: %s": "Интеграция не найдена: %s",
    "(Collector)<br>%s": "(Сборщик)<br>%s",
    "Failed to create integration: %s": "Не удалось создать интеграцию: %s",
    "Failed to delete integration: %s": "Не удалось удалить интеграцию: %s",
    "Failed to prune orphaned channels: %s": "Не удалось очистить осиротевшие каналы: %s",
    "Unknown maintenance action.": "Неизвестное действие обслуживания.",
    "Failed to retrieve channels from database: %s": "Не удалось получить каналы из базы данных: %s",
    "Could not get queue list from RabbitMQ Management API. Ensure the API is accessible and credentials are correct in config.json. Error: %v": "Не удалось получить список очередей из RabbitMQ Management API. Убедитесь, что API доступен и учетные данные верны в config.json. Ошибка: %v",
    "Transformation created successfully!": "Трансформация успешно создана!",
    "Transformation deleted.": "Трансформация удалена.",
    "Transformation updated successfully!": "Трансформация успешно обновлена!",
    "Name, engine, and script are required.": "Имя, движок и скрипт обязательны для заполнения.",
    "Failed to retrieve transformations: %s": "Не удалось получить трансформации: %s",
    "Failed to retrieve transformation: %s": "Не удалось получить трансформацию: %s",
    "Transformation not found.": "Трансформация не найдена.",
    "Failed to create transformation: %s": "Не удалось создать трансформацию: %s",
    "Failed to update transformation: %s": "Не удалось обновить трансформацию: %s",
    "Failed to delete transformation: %s": "Не удалось удалить трансформацию: %s",
    "Failed to delete route: %s": "Не удалось удалить маршрут: %s",
    "main": "main",
    "Main process": "Основной процесс",
    "ESB Admin Panel": "Админ-панель ESB",
    "Integrations": "Интеграции",
    "Routes": "Маршруты",
    "Transformations": "Трансформации",
    "Collectors": "Сборщики",
    "Back to application list": "Назад к списку приложений",
    "Details": "Детали",
    "Edit Application": "Редактировать приложение",
    "Save": "Сохранить",
    "Channels": "Каналы",
    "Create New Channel": "Создать новый канал",
    "Channel Name:": "Название канала:",
    "Direction:": "Направление:",
    "If checked, the channel will fan-out messages to all subscribing routes. Otherwise, routes will compete for messages.": "Если включено, канал будет раздавать копии сообщений всем маршрутам-подписчикам. Иначе маршруты будут конкурировать за сообщения.",
    "Fan-out": "Не удалять",
    "Destination (Queue):": "Назначение (очередь):",
    "Create Channel": "Создать канал",
    "Existing Channels": "Существующие каналы",
    "Direction": "Направление",
    "Test": "Тест",
    "Send": "Отправить",
    "Receive 1": "Получить 1",
    "Are you sure you want to delete this channel?": "Вы уверены, что хотите удалить этот канал?",
    "No channels created.": "Нет созданных каналов.",
    "Message Received:": "Полученное сообщение:",
    "Back to application": "Назад к приложению",
    "Edit Channel": "Редактировать канал",
    "Fan-out Mode": "Режим Не удалять",
    "Fan-out mode (distribute copies to subscribers)": "Режим Не удалять (раздавать копии подписчикам)",
    "Update Channel": "Обновить канал",
    "Collector Management": "Управление сборщиками",
    "Collectors are autonomous scripts that run on a schedule to retrieve data from external sources and publish it to an internal channel.": "Сборщики - это автономные скрипты, которые запускаются по расписанию для получения данных из внешних источников и публикации их во внутренний канал.",
    "Create New Collector": "Создать нового сборщика",
    "Schedule (Cron)": "Расписание (Cron)",
    "Engine": "Движок",
    "Script": "Скрипт",
    "Create Collector": "Создать сборщика",
    "Existing Collectors": "Существующие сборщики",
    "Schedule": "Расписание",
    "Are you sure you want to delete this collector?": "Вы уверены, что хотите удалить этого сборщика?",
    "No collectors created yet.": "Пока не создано ни одного сборщика.",
    "Editing Collector": "Редактирование сборщика",
    "Here you can edit an existing data collector.": "Здесь вы можете изменить существующий сборщик данных.",
    "Save Changes": "Сохранить изменения",
    "Help with writing scripts for collectors": "Помощь по написанию скриптов для сборщиков",
    "Collector scripts are used to retrieve data from external sources and publish them to the ESB system. The script must return an array of JSON objects. Each object in the array will be published as a separate message.": "Скрипты сборщиков используются для получения данных из внешних источников и их публикации в систему ESB. Скрипт должен вернуть массив JSON-объектов. Каждый объект в массиве будет опубликован как отдельное сообщение.",
    "Basic Principles:": "Основные принципы:",
    "Return Value:": "Возвращаемое значение:",
    "The script MUST return a JSON-compatible array or a single JSON object. For example, `[{\"key\": \"value\"}, {\"another_key\": \"another_value\"}]` or `{\"another_key\": \"another_value\"}`. If the script returns `null` or nothing, no messages will be published.": "Скрипт **обязательно** должен возвращать JSON-совместимый массив или одиночный JSON-объект. Например, `[{\"key\": \"value\"}, {\"another_key\": \"another_value\"}]` или `{\"another_key\": \"another_value\"}`. Если скрипт возвращает `null` или не возвращает ничего, сообщения не будут опубликованы.",
    "Message Publication:": "Публикация сообщений:",
    "Your task is only to receive and structure the data. The collector itself handles the publication of messages to RabbitMQ.": "Ваша задача — только получить и структурировать данные. Публикацию сообщений в RabbitMQ осуществляет сам сборщик.",
    "Error Handling:": "Обработка ошибок:",
    "Any errors that occur during script execution will be logged in the ESB logs.": "Любые ошибки, возникающие в процессе выполнения скрипта, будут регистрироваться в логах ESB.",
    "Available Global Objects:": "Доступные глобальные объекты:",
    "`log`: An object for logging information to the ESB console (e.g., `log.info(\"My message\")`, `log.warn(\"Warning\")`, `log.error(\"Error\")`).": "`log`: Объект для логирования информации в консоль ESB (например, `log.info(\"Мое сообщение\")`, `log.warn(\"Предупреждение\")`, `log.error(\"Ошибка\")`).",
    "`fetch` (JavaScript only): A function for making HTTP requests. Returns an object with `status` (number) and `json()` (function for parsing the response body) fields.": "`fetch` (только для JavaScript): Функция для выполнения HTTP-запросов. Возвращает объект с полями `status` (число) и `json()` (функция для парсинга тела ответа).",
    "`http` (Starlark only): An object with methods `get(url)`, `post(url, body, headers)`, etc. Returns an object with `status_code` (number) and `json()` (function for parsing the response body) fields.": "`http` (только для Starlark): Объект с методами `get(url)`, `post(url, body, headers)` и т.д. Возвращает объект с полями `status_code` (число) и `json()` (функция для парсинга тела ответа).",
    "Script Examples:": "Примеры скриптов:",
    "JavaScript (Goja)": "JavaScript (Goja)",
    "Example of getting data from an external API and returning a list of objects:": "Пример получения данных из внешнего API и возврата списка объектов:",
    "// Execute HTTP GET request": "// Выполняем HTTP GET запрос",
    "// Check response status": "// Проверяем статус ответа",
    "var data = response.json(); // Parse JSON response": "var data = response.json(); // Парсим JSON ответ",
    "log.info(\"Received data: \" + JSON.stringify(data));": "log.info(\"Получены данные: \" + JSON.stringify(data));",
    "return data; // Return an array of objects": "return data; // Возвращаем массив объектов",
    "log.error(\"Error receiving data: \" + response.status);": "log.error(\"Ошибка при получении данных: \" + response.status);",
    "return null; // Return null in case of an error, so as not to publish a message": "return null; // В случае ошибки возвращаем null, чтобы не публиковать сообщение",
    "log.info(\"Received data: %s\" % data)": "log.info(\"Получены данные: %s\" % data)",
    "data # Return data": "data # Возвращаем данные",
    "log.error(\"Error receiving data: %s\" % response.status_code)": "log.error(\"Ошибка при получении данных: %s\" % response.status_code)",
    "None # Return None so as not to publish a message": "None # Возвращаем None, чтобы не публиковать сообщение",
    "Important:": "Важно:",
    "For making HTTP requests in Starlark, the global object `http` is used. For JavaScript, the global function `fetch` is used.": "Для выполнения HTTP-запросов в Starlark используется глобальный объект `http`. Для JavaScript используется глобальная функция `fetch`.",
    "Integrations are logical groups for your routes and collectors.": "Интеграции - это логические группы для ваших маршрутов и сборщиков.",
    "Create New Integration": "Создать новую интеграцию",
    "Integration Name:": "Название интеграции:",
    "Description:": "Описание:",
    "Existing Integrations": "Существующие интеграции",
    "Description": "Описание",
    "Are you sure you want to delete this integration?": "Вы уверены, что хотите удалить эту интеграцию?",
    "No integrations created.": "Нет созданных интеграций.",
    "Back to integrations list": "Назад к списку интеграций",
    "Integration:": "Интеграция:",
    "Process Diagram": "Диаграмма процесса",
    "No collectors for this integration.": "Для этой интеграции нет сборщиков.",
    "No routes for this integration.": "Для этой интеграции нет маршрутов.",
    "Integration not found.": "Интеграция не найдена.",
    "Back to main page": "Назад на главную",
    "RabbitMQ Queue Reconciliation": "Сверка очередей RabbitMQ",
    "This page compares the channels defined in the application database with the actual queues in RabbitMQ.": "Эта страница сравнивает каналы, определенные в базе данных приложения, с реальными очередями в RabbitMQ.",
    "This helps to find 'orphaned' queues (which exist in RabbitMQ but are no longer used in the ESB) for manual cleanup.": "Это помогает найти 'осиротевшие' очереди (которые существуют в RabbitMQ, но больше не используются в ESB) для ручной очистки.",
    "'Orphaned' queues in RabbitMQ": "'Осиротевшие' очереди в RabbitMQ",
    "These queues exist in RabbitMQ, but there are no corresponding channels in the ESB database. They can be safely deleted in the RabbitMQ management panel.": "Эти очереди существуют в RabbitMQ, но для них нет соответствующих каналов в базе данных ESB. Их можно безопасно удалить в панели управления RabbitMQ.",
    "No orphaned queues found.": "Осиротевших очередей не найдено.",
    "Missing queues in RabbitMQ": "Отсутствующие очереди в RabbitMQ",
    "For these channels, there is an entry in the ESB database, but the corresponding queue in RabbitMQ was not found. They may need to be created again.": "Для этих каналов есть запись в базе данных ESB, но соответствующая очередь в RabbitMQ не найдена. Возможно, их нужно создать заново.",
    "No missing queues found.": "Отсутствующих очередей не найдено.",
    "Matching queues": "Совпадающие очереди",
    "No matching queues found.": "Совпадающих очередей не найдено.",
    "Transformation Management": "Управление трансформациями",
    "Here you can create and manage message transformation scripts.": "Здесь вы можете создавать и управлять скриптами трансформации сообщений.",
    "Create New Transformation": "Создать новую трансформацию",
    "Create Transformation": "Создать трансформацию",
    "Existing Transformations": "Существующие трансформации",
    "Are you sure you want to delete this transformation?": "Вы уверены, что хотите удалить эту трансформацию?",
    "No transformations created yet.": "Пока не создано ни одной трансформации.",
    "Editing Transformation": "Редактирование трансформации",
    "Here you can edit an existing transformation script.": "Здесь вы можете изменить существующий скрипт трансформации.",
    "Help with writing scripts for transformations": "Помощь по написанию скриптов для трансформаций",
    "Transformation scripts are used to modify incoming messages before they are routed to their destination. The script receives the message body and headers, and should return the modified message body or `null`/`None` to filter the message.": "Скрипты трансформации используются для изменения входящих сообщений перед их маршрутизацией к назначению. Скрипт получает тело сообщения и заголовки, и должен вернуть измененное тело сообщения или `null`/`None` для фильтрации.",
    "Input Data:": "Входные данные:",
    "`message`: An object representing the body of the incoming message (JSON).": "`message`: Объект, представляющий тело входящего сообщения (JSON).",
    "`headers`: An object containing the headers of the incoming message.": "`headers`: Объект, содержащий заголовки входящего сообщения.",
    "The script MUST return a JSON-compatible object that will become the new message body.": "Скрипт **обязательно** должен возвращать JSON-совместимый объект, который станет новым телом сообщения.",
    "Message Filtering:": "Фильтрация сообщений:",
    "If the script returns `null` (JavaScript) or `None` (Starlark), the message will be filtered and will not be sent to the destination channel.": "Если скрипт возвращает `null` (JavaScript) или `None` (Starlark), сообщение будет отфильтровано и не будет отправлено в канал назначения.",
    "log.info(\"Incoming message: \" + JSON.stringify(message));": "log.info(\"Входящее сообщение: \" + JSON.stringify(message));",
    "log.info(\"Headers: \" + JSON.stringify(headers));": "log.info(\"Заголовки: \" + JSON.stringify(headers));",
    "// Add a new field": "// Добавляем новое поле",
    "message.processed_by = \"esb-transformer\";": "message.processed_by = \"esb-transformer\";",
    "// Filter the message if the 'status' field is 'draft'": "// Фильтруем сообщение, если поле 'status' равно 'draft'",
    "if (message.status === \"draft\") {": "if (message.status === \"draft\") {",
    "log.info(\"Message with status 'draft' has been filtered.\");": "log.info(\"Сообщение со статусом 'draft' отфильтровано.\");",
    "return null; // Filter the message": "return null; // Отфильтровать сообщение",
    "return message; // Return the modified message": "return message; // Возвращаем измененное сообщение",
    "// The script must return an execute function or the result immediately": "// Скрипт должен возвращать функцию execute или сразу результат",
    "Starlark (Python-like)": "Starlark (Python-подобный)",
    "# Main script logic": "# Основная логика скрипта",
    "log.info(\"Received data: %s\" % message)": "log.info(\"Входящее сообщение: %s\" % message)",
    "log.info(\"Headers: %s\" % headers)": "log.info(\"Заголовки: %s\" % headers)",
    "# Change a field": "# Изменяем поле",
    "message[\"status\"] = \"processed\"": "message[\"status\"] = \"processed\"",
    "# Filter the message if 'X-Ignore' is in the headers": "# Фильтруем сообщение, если в заголовках есть 'X-Ignore'",
    "if \"X-Ignore\" in headers:": "if \"X-Ignore\" in headers:",
    "log.info(\"Message with header 'X-Ignore' has been filtered.\")": "log.info(\"Сообщение с заголовком 'X-Ignore' отфильтровано.\")",
    "return None # Filter the message": "return None # Отфильтровать сообщение",
    "return message # Return the modified message": "return message # Возвращаем измененное сообщение",
    "# Assume we have a 'type' field in the message": "# Предположим, что у нас есть поле 'type' в сообщении",
    "if message.get(\"type\") == \"order\":": "if message.get(\"type\") == \"order\":",
    "message[\"routing_key\"] = \"orders.new\"": "message[\"routing_key\"] = \"orders.new\"",
    "elif message.get(\"type\") == \"cancel\":": "elif message.get(\"type\") == \"cancel\":",
    "message[\"routing_key\"] = \"orders.cancelled\"": "message[\"routing_key\"] = \"orders.cancelled\"",
    "else:": "else:",
    "message[\"routing_key\"] = \"orders.default\"": "message[\"routing_key\"] = \"orders.default\"",
    "log.info(\"Message prepared for routing with key: %s\" % message[\"routing_key\"])": "log.info(\"Сообщение подготовлено для маршрутизации с ключом: %s\" % message[\"routing_key\"])",
    "Important: Make sure your script always returns an object (even if it's an empty `{}`) or `null`/`None`. The actual routing decision is made by the ESB router based on the modified message (e.g., by the added `routing_key`).": "Важно: Убедитесь, что ваш скрипт всегда возвращает объект (даже если он пустой `{}`) или `null`/`None`. Фактическое решение о маршрутизации принимается маршрутизатором ESB на основе измененного сообщения (например, по добавленному `routing_key`)."
}