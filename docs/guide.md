# ESB Go App

Сервис управления очередями RabbitMQ с использованием объектов 1с СервисИнтеграции

## Архитектура и запуск (Docker Compose)

Проект использует `docker-compose` для простого запуска всей среды, состоящей из двух контейнеров:

* `go-app`: Данный сервис.
* `rabbitmq`: Стандартный образ RabbitMQ.

Контейнеры работают в одной виртуальной сети Docker, что позволяет им обращаться друг к другу по имени.

### Как запустить

1. Убедитесь, что у вас установлен Docker и Docker Compose.
2. Выполните команду в терминале:

    ```bash
    docker-compose up --build
    ```

### Как проверить

1. После запуска контейнеров откройте в браузере административную панель сервиса:
    `http://localhost:8080/admin` - сервис
    `http://localhost:15672` - RabbitMQ (логин: quest, пароль: quest)

## Описание

Сервис реализует возможность использования сервисов интеграции совместно с RabbitMQ.
В момент тестирования выяснилось, что платформа 1с (тесты на 8.3.24) использует временные очереди, что подрывает принципы стабильности обменов с использованием шин данных, после рестарта RabbitMQ при неработающей платформе 1с временные очереди недоступны и отправка сообщений в них осуществляться не может.
В связи с этим в сервисе реализовано создание постоянных очередей, которые связаны с очередями создаваемыми платформой 1с.
В момент активации временных очередей создаваемых платформой 1с начинается "перенаправление" сообщений обмена между связанными постоянными и временными очередями.
Одновременно осуществляется отправка сообщений по настроенным маршрутам, что позволяет связать входящие и исходящие очереди различных приложений.
Для удобства использования все настроенные маршруты, сборщики, трансформации можно объединять в интеграции.
Доступно создание трансформаций сообщений. Поддерживаются скрипты трансформации на `Java Script`, `Starlark (python)`.
Доступно создание коллекторов сообщений.  Поддерживаются скрипты коллекторов на `Java Script`, `Starlark (python)`. Коллекторы позволяют получать `http` сообщения с дальнейшим направлением их в очереди.
Подробно процессы представлены на диаграммах.

![картинка](/docs/images/component_diagram.png)

![картинка](/docs/images/sequence_diagram_inbound.png)

![картинка](/docs/images/sequence_diagram_outbound.png)

![картинка](/docs/images/sequence_diagram_routing.png)

![картинка](/docs/images/sequence_diagram_collection.png)

### Создание приложений

На странице `http://localhost:8080/admin` вводим название приложения и жмем `Создать`. Приложение это приложение в адресе СервисаИнтеграции в метаданных 1с. По пути будут получены Каналы, которым в сервисе соответствуют очереди.
Так же приложения могут создаваться для других целей, например технических, чтобы организовать маршрутизацию сообщений.

![картинка](/docs/images/002.png)

### Создание очередей (каналов)

Для приложения в сервисе создаются входящий и исходящий каналы. Одновременно с созданием каналов в RabbitMQ будут созданы технические постоянные очереди, с которыми будут взаимодействовать внешние приложения и которые будут использовать временные каналы создаваемые платформой 1с.
Если при создании очереди установить флаг `Не удалять`, будет создана очередь сообщения из которой могут получать несколько потребителей. Например, такая очередь необходима для условной трансформации сообщений.

![картинка](/docs/images/003.png)

### Пересоздание очередей

![картинка](/docs/images/001.png)

На странице администрирования доступна кнопка `Пересоздать все очереди и мосты`, которая позволяет пересоздать все очереди в RabbitMQ, если по каким-то причинам очереди не сохранились при рестарте брокера.

### Удаление зависших каналов

Если случайно удалили приложение, предварительно не удалив его каналы, это можно сделать на главной странице кнопкой `Удалить осиротевшие каналы`. Удаление происходит только в базе данных сервиса.

### Интеграция

Интеграция позволяет объединить для удобства использования маршруты, трансформации, сборщики.

![картинка](/docs/images/011.png)

### Маршрутизация сообщений

Сервис поддерживает маршрутизацию сообщений между различными приложениями. Это позволяет создавать сложные цепочки обработки сообщений, где одно приложение может отправлять сообщения напрямую в очередь другого.
В маршрутизации доступны `Трансформации` и  `Сборщики`. Это позволяет строить сложные цепочки взаимодействия приложений и очередей.

#### Концепция

Основная идея заключается в создании **Маршрута**. Маршрут — это правило, которое связывает один исходящий (outbound) канал одного приложения с одним входящим (inbound) каналом другого.

Дополнительно маршруты связывают `Сборщиков` и `Трансформации` с каналами.

Когда сообщение появляется в постоянной очереди исходящего канала, специальный воркер-маршрутизатор (Router) перекладывает это сообщение в постоянную очередь входящего канала-получателя. Это гарантирует надежную доставку по всему пути следования.

#### Настройка

1. **Создайте необходимые каналы**: Убедитесь, что у приложений-источников есть outbound каналы, а у приложений-получателей — inbound каналы.
2. **Перейдите в раздел "Маршруты"**: В админ-панели появился новый раздел "Маршруты".
3. **Создайте маршрут**:
    * В форме "Создать новый маршрут" выберите из выпадающих списков, из какого outbound канала (источник) и в какой inbound канал (получатель) вы хотите направлять сообщения.
    * Нажмите "Создать маршрут".
4. **Проверка**: Новый маршрут появится в списке "Существующие маршруты". Сервис автоматически запустит необходимый фоновый процесс для обработки этого маршрута.

![картинка](/docs/images/004.png)

Очереди в RabbitMQ.

![картинка](/docs/images/005.png)

### Трансформация

Трансформация позволяет обработать входящее сообщение, получить дополнительные данные из внешнего `http` сервиса. Для создания условной обработки необходимо сделать входящий канал `Не удалять`.
Скрипты трансформации могут быть написаны на `java script` или `starlark (python)`.
[Пример маршрута с трансформацией](/docs/end_to_end_example.md)

![картинка](/docs/images/012.png)

### Сборщик

Сборщик позволяет получить сообщение из внешнего `http` сервиса и далее направить его в очередь для обработки. Для сборщика доступна настройка расписания.
Скрипты сборщика могут быть написаны на `java script` или `starlark (python)`.

![картинка](/docs/images/013.png)

### Тестирование

Создаем тестовое сообщение в канале `app_to_any`.

![картинка](/docs/images/006.png)

После отправки сообщение идет по настроенному маршруту и попадает в очередь приемника.

![картинка](/docs/images/007.png)

И его можно получить в приемнике. Кнопкой `Получить 1` получается только одно сообщение.

![картинка](/docs/images/008.png)

### Настройка в 1с

После создания каналов приложения в сервисе в 1с необходимо получить каналы. Для этого следует использовать команду сервиса интеграции `Действия - Загрузить каналы`. В поле `Адрес сервиса` вводим адрес приложения, например `http://localhost:8080/applications/app1` в поле `Пользователь` вводим `ID` приложения, в поле `Пароль` вводим `Пароль` приложения. Жмем `Получить каналы сервиса`.

![картинка](/docs/images/009.png)

Аналогичные данные необходимо вводить в поля редактирования сервиса в режиме 1с `Предприятие` при активации сериса интеграции `Функции для технического специалиста - Стандартные - Управление сервисами интеграции`. Ставим флаг активности и в режиме редактирования заполняем поля.

![картинка](/docs/images/010.png)

Подробно весь процесс настройки сервисов интеграции и их программной реализации смотреть в документации по платформе 1с и 1с шине (описаны примеры реализации).

## Мониторинг и Метрики

Сервис предоставляет метрики в формате Prometheus для мониторинга его состояния и производительности.

### Эндпоинт

Метрики доступны по адресу:

`http://localhost:8080/metrics`

### Основные метрики

* **esb_go_messages_processed_total**: Общее количество обработанных сообщений.
    * worker_type: тип воркера (inbound, outbound, outer).
    * source: очередь-источник.
    * destination: очередь/обменник назначения.

* **esb_go_errors_total**: Общее количество ошибок, возникших в воркерах.
    * worker_type: тип воркера (inbound, outbound, outer).

* **esb_go_active_workers**: Текущее количество активных воркеров.
    * worker_type: тип воркера (inbound, outbound, outer).
